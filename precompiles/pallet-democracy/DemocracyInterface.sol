// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.0;

/// The interface through which solidity contracts will interact with pallet-democracy
///
/// This interface does not exhaustively wrap pallet democracy, rather it wraps the most
/// important parts and the parts that are expected to be most useful to evm contracts.
/// More exhaustive wrapping can be added later if it is desireable and the pallet interface
/// is deemed sufficiently stable.
interface Democracy {
    // First some simple accessors

    /// Get the total number of public proposals past and present
    function public_prop_count() external view returns (uint256);

    // Now the dispatchables

    /// Make a new proposal with the given hash locking the given value
    function propose(bytes32 proposal_hash, uint256 value) external;

    /// Signals agreement with a particular proposal
    function second(uint256 proposal, uint256 seconds_upper_bound) external;

    //TODO in the future we could consider using a solidity struct here for AccountVote
    // like they do in the Rust code. For now I'll just accept each param individually.
    /// Vote in a referendum. If `true`, the vote is to enact the proposal;
    /// otherwise it is a vote to keep the status quo.
    ///
    /// This only supposrts "Standard" vites where you euther vote aye or nay.
    /// It does not support split votes where you vote on both sides.
    function stardard_vote(
        uint256 ref_index,
        bool aye,
        uint256 vote_amount,
        uint256 conviction
    ) external;

    /// Remove a vote for a referendum by index. See pallet-democracy's docs for details
    /// about how locks are handled when votes are removed.
    function remove_vote(uint256 index) external;

    /// Delegate the voting power (with some given conviction) of the sending account.
    ///
    /// The balance delegated is locked for as long as it's delegated, and thereafter for the
    /// time appropriate for the conviction's lock period.
    function delegate(
        address to,
        uint256 conviction,
        uint256 amount
    ) external;

    /// Undelegate the voting power of the sending account.
    ///
    /// Tokens may be unlocked following once an amount of time consistent with the lock period
    /// of the conviction with which the delegation was issued.
    function un_delegate() external;

    /// Unlock tokens that have an expired lock.
    function unlock(address target) external;
}

// These are the selectors generated by remix following this advice
// https://ethereum.stackexchange.com/a/73405/9963
// Eventually we will probably want a better way of generating these and copying them to Rust
// {
//     "0185921e": "delegate(address,uint256,uint256)",
//     "7824e7d1": "propose(bytes32,uint256)",
//     "56fdf547": "public_prop_count()",
//     "2042f50b": "remove_vote(uint256)",
//     "c7a76601": "second(uint256,uint256)",
//     "35cde7ae": "stardard_vote(uint256,bool,uint256,uint256)",
//     "cb37b8ea": "un_delegate()",
//     "2f6c493c": "unlock(address)"
// }
